<!DOCTYPE html>
<html lang="en">
	<head>
		<title>AR DEMO</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
		<style>
			* {
			  margin: 0;
			  padding: 0;
			}
		  </style>
	</head>
	<body>
		<video id="video" style="position: absolute; z-index: -1; 
		top: 0;
		left: 0;
		width: 100%;
		height: 100%;
		object-fit: fill;" >
		</video>
		<div>
		  <button id="capture" style="position: absolute;">打开相机</button>
		</div>
		<script>
		  document.getElementById('capture').addEventListener('click', function () {
			getRealMedia()
		  })

		function getRealMedia() {
			if (!navigator.mediaDevices.getUserMedia) {
				Toast('您的系统暂不支持AR导航');
				return;
			}

			navigator.mediaDevices.enumerateDevices()
			.then(devices => {
				var videoDevices = [];
				devices.forEach(function (device) {
					if (device.kind == "videoinput") {
						videoDevices.push(device.deviceId)
					}
				});
				console.log(videoDevices)
				var constraints = {
					width: 375,
					height: 500,
					deviceId: {
						exact: videoDevices[videoDevices.length - 1]
					}
				};
				return navigator.mediaDevices.getUserMedia({
					video: constraints
				});

			})
			.then(stream => {
				let video = document.getElementById('video');
				video.srcObject = stream;
				video.play();
				stopId = stream.getTracks()[stream.getTracks().length - 1];
			})
			.catch(e => console.error(e));
		}
		</script>

		<script type="module">
		
			import * as THREE from './three.module.js';
			import { FirstPersonCameraControl } from './FirstPersonCameraControl.js';
			import { GLTFLoader } from './GLTFLoader.js';
			import { RGBELoader } from './RGBELoader.js';
			import { EquirectangularToCubeGenerator } from './EquirectangularToCubeGenerator.js';
			import { PMREMGenerator } from './PMREMGenerator.js';
			import { PMREMCubeUVPacker } from './PMREMCubeUVPacker.js';

			import { OrbitControls } from './OrbitControls.js';

			var mixerCnt = 0
			var mixer;
			var mixers = []
			var clock = new THREE.Clock();

			var camera, scene, renderer, controls;

			var objects = [];

			var raycaster;

			var moveForward = false;
			var moveBackward = false;
			var moveLeft = false;
			var moveRight = false;
			var canJump = false;

			var prevTime = performance.now();
			var velocity = new THREE.Vector3();
			var direction = new THREE.Vector3();
			var vertex = new THREE.Vector3();
			var color = new THREE.Color();

			var cnt = 0

			

			init();
			animate();

			function init() {

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.01, 100000 );
				// camera.position.set( 3,1,7 );
				camera.position.y = 200;
				camera.position.z = 3000;

				scene = new THREE.Scene();
				scene.background = null;
				// scene.fog = new THREE.Fog( 0xffffff, 0, 7500 );

				var light = new THREE.AmbientLight( 0xffffff, 1);
				scene.add( light );
				var directionalLight = new THREE.DirectionalLight( 0xffffff, 1 );
				directionalLight.position.set( 0, 0, -1 );
				scene.add( directionalLight );			

				raycaster = new THREE.Raycaster( new THREE.Vector3(), new THREE.Vector3( 0, - 1, 0 ), 0, 10 );

				// floor

				var floorGeometry = new THREE.PlaneBufferGeometry( 2000, 2000, 100, 100 );
				floorGeometry.rotateX( - Math.PI / 2 );

				// vertex displacement

				var position = floorGeometry.attributes.position;

				for ( var i = 0, l = position.count; i < l; i ++ ) {

					vertex.fromBufferAttribute( position, i );

					vertex.x += Math.random() * 20 - 10;
					vertex.y += Math.random() * 2;
					vertex.z += Math.random() * 20 - 10;

					position.setXYZ( i, vertex.x, vertex.y, vertex.z );

				}

				floorGeometry = floorGeometry.toNonIndexed(); // ensure each face has unique vertices

				position = floorGeometry.attributes.position;
				var colors = [];

				for ( var i = 0, l = position.count; i < l; i ++ ) {

					color.setHSL( Math.random() * 0.3 + 0.5, 0.75, Math.random() * 0.25 + 0.75 );
					colors.push( color.r, color.g, color.b );

				}

				floorGeometry.addAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );

				var floorMaterial = new THREE.MeshBasicMaterial( { vertexColors: THREE.VertexColors } );

				var floor = new THREE.Mesh( floorGeometry, floorMaterial );
				// scene.add( floor );

				// objects

				var boxGeometry = new THREE.BoxBufferGeometry( 20, 20, 20 );
				boxGeometry = boxGeometry.toNonIndexed(); // ensure each face has unique vertices

				position = boxGeometry.attributes.position;
				colors = [];

				for ( var i = 0, l = position.count; i < l; i ++ ) {

					color.setHSL( Math.random() * 0.3 + 0.5, 0.75, Math.random() * 0.25 + 0.75 );
					colors.push( color.r, color.g, color.b );

				}

				boxGeometry.addAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );

				for ( var i = 0; i < 0; i ++ ) {

					var boxMaterial = new THREE.MeshPhongMaterial( { specular: 0xffffff, flatShading: true, vertexColors: THREE.VertexColors } );
					boxMaterial.color.setHSL( Math.random() * 0.2 + 0.5, 0.75, Math.random() * 0.25 + 0.75 );

					var box = new THREE.Mesh( boxGeometry, boxMaterial );
					box.position.x = Math.floor( Math.random() * 20 - 10 ) * 20;
					box.position.y = Math.floor( Math.random() * 20 );
					box.position.z = Math.floor( Math.random() * 20 - 10 ) * 50;

					scene.add( box );
					objects.push( box );

				}

				//

				renderer = new THREE.WebGLRenderer( {
					 antialias: true,
					 alpha:true
					 } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				//
				// controls = new FirstPersonCameraControl( camera, renderer.domElement );
				// controls.enabled = true;	
				
				controls = new OrbitControls( camera, renderer.domElement );
				controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
				controls.dampingFactor = 0.05;

				controls.screenSpacePanning = false;

				controls.minDistance = 0.01;
				controls.maxDistance = 50000;

				// controls.maxPolarAngle = Math.PI / 2;
				

				window.addEventListener( 'resize', onWindowResize, false );

				for (var m = 0; m < 1; m++) {
					loadObj()
					cnt++
				}
			}

			function loadObj() {
					var loader = new GLTFLoader().setPath( 'models/gltf/Monster/glb2/' );
					loader.load( '手机1.glb', function ( gltf ) {
						gltf.scene.traverse( function ( child ) {

							// if ( child.isMesh ) {

							// 	child.material.map = child.material.emissiveMap
							// 	child.material.emissiveMap = null


							// 	// child.material.color.g = 0.5;
							// 	// child.material.color.b = 0.5;

							// 	// child.material.emissive.r = 0.5;
							// 	// child.material.emissive.g = 0.5;
							// 	// child.material.emissive.b = 0.5;

							// }

							if (child.isMesh && child.name && child.name == '挤压') {

								// console.log('add')
								
								// // child.visible = false
								// scene.add( child );

								}		
							
							
							console.log(child)

						} );
						var animations = gltf.animations;

						if ( animations && animations.length ) {

							mixers[mixerCnt] = new THREE.AnimationMixer( gltf.scene );

							for ( var i = 0; i < animations.length; i ++ ) {

								var animation = animations[ i ];

								// There's .3333 seconds junk at the tail of the Monster animation that
								// keeps it from looping cleanly. Clip it at 3 seconds
								// if ( sceneInfo.animationTime ) {

									animation.duration = 3;

								// }

								var action = mixers[mixerCnt].clipAction( animation );
								action.play();

							}

							mixerCnt++
						}

						var change =  1;
						// if (cnt % 2 == 0) {
						// 	change =  -1
						// }
						// gltf.scene.position.set(change * Math.floor( Math.random() * 20 - 10 ) * 20,
						// change * Math.floor( Math.random() * 40 - 10 ),
						// change * Math.floor( Math.random() * 40 - 10 ) * 20)
						scene.add( gltf.scene );
					})
					
				// 	);

				// 	pmremGenerator.dispose();
				// 	pmremCubeUVPacker.dispose();

				// 	// scene.background = cubeGenerator.renderTarget;

				// } );
			}

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			var dis = 0
			var change = false
			function animate() {
				requestAnimationFrame( animate );

				controls.update();
				// // console.log(clock.getDelta())
				// for (var i = 0; i < 10; i++) {
				// 	if (mixers[i]) {
				// 		mixers[i].update( 0.01 );
				// 	}
				// }
				// // if ( mixer ) mixer.update( 0.01 );
				renderer.render( scene, camera );
			}
		</script>
	</body>
</html>
