<!DOCTYPE html>
<html lang="en">
	<head>
		<title>AR DEMO</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
		<style>
			* {
			  margin: 0;
			  padding: 0;
			}
		  </style>
	</head>
	<body>
		<video id="video" style="position: absolute; z-index: -1; 
		top: 0;
		left: 0;
		width: 100%;
		height: 100%;
		object-fit: fill;" >
		</video>
		<div>
		  <button id="capture" style="position: absolute;">打开相机</button>
		</div>
		<script>
		  document.getElementById('capture').addEventListener('click', function () {
			getRealMedia()
		  })

		function getRealMedia() {
			if (!navigator.mediaDevices.getUserMedia) {
				Toast('您的系统暂不支持AR导航');
				return;
			}

			navigator.mediaDevices.enumerateDevices()
			.then(devices => {
				var videoDevices = [];
				devices.forEach(function (device) {
				if (device.kind == "videoinput") {
					videoDevices.push(device.deviceId)
				}
				});
				console.log(videoDevices)
				var constraints = {
				width: 375,
				height: 500,
				deviceId: {
					exact: videoDevices[videoDevices.length - 1]
				}
				};
				return navigator.mediaDevices.getUserMedia({
				video: constraints
				});

			})
			.then(stream => {
				let video = document.getElementById('video');
				video.srcObject = stream;
				video.play();
				stopId = stream.getTracks()[stream.getTracks().length - 1];
			})
			.catch(e => console.error(e));
		}
		</script>

		<script type="module">
		
			import * as THREE from './three.module.js';
			import { FirstPersonCameraControl } from './FirstPersonCameraControl.js';
			import { GLTFLoader } from './GLTFLoader.js';
			import { RGBELoader } from './RGBELoader.js';
			import { EquirectangularToCubeGenerator } from './EquirectangularToCubeGenerator.js';
			import { PMREMGenerator } from './PMREMGenerator.js';
			import { PMREMCubeUVPacker } from './PMREMCubeUVPacker.js';

			var mixerCnt = 0
			var mixer;
			var mixers = []
			var clock = new THREE.Clock();

			var camera, scene, renderer, controls;

			var objects = [];

			var raycaster;

			var moveForward = false;
			var moveBackward = false;
			var moveLeft = false;
			var moveRight = false;
			var canJump = false;

			var prevTime = performance.now();
			var velocity = new THREE.Vector3();
			var direction = new THREE.Vector3();
			var vertex = new THREE.Vector3();
			var color = new THREE.Color();

			var cnt = 0

			

			init();
			animate();

			function init() {

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 10000 );
				// camera.position.set( 3,1,7 );
				camera.position.y = 200;
				camera.position.z = 1000;

				scene = new THREE.Scene();
				scene.background = null;
				// scene.fog = new THREE.Fog( 0xffffff, 0, 7500 );

				var light = new THREE.HemisphereLight( 0xeeeeff, 0x777788, 0.75 );
				light.position.set( 0.5, 1, 0.75 );
				scene.add( light );
				raycaster = new THREE.Raycaster( new THREE.Vector3(), new THREE.Vector3( 0, - 1, 0 ), 0, 10 );

				// floor

				var floorGeometry = new THREE.PlaneBufferGeometry( 2000, 2000, 100, 100 );
				floorGeometry.rotateX( - Math.PI / 2 );

				// vertex displacement

				var position = floorGeometry.attributes.position;

				for ( var i = 0, l = position.count; i < l; i ++ ) {

					vertex.fromBufferAttribute( position, i );

					vertex.x += Math.random() * 20 - 10;
					vertex.y += Math.random() * 2;
					vertex.z += Math.random() * 20 - 10;

					position.setXYZ( i, vertex.x, vertex.y, vertex.z );

				}

				floorGeometry = floorGeometry.toNonIndexed(); // ensure each face has unique vertices

				position = floorGeometry.attributes.position;
				var colors = [];

				for ( var i = 0, l = position.count; i < l; i ++ ) {

					color.setHSL( Math.random() * 0.3 + 0.5, 0.75, Math.random() * 0.25 + 0.75 );
					colors.push( color.r, color.g, color.b );

				}

				floorGeometry.addAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );

				var floorMaterial = new THREE.MeshBasicMaterial( { vertexColors: THREE.VertexColors } );

				var floor = new THREE.Mesh( floorGeometry, floorMaterial );
				// scene.add( floor );

				// objects

				var boxGeometry = new THREE.BoxBufferGeometry( 20, 20, 20 );
				boxGeometry = boxGeometry.toNonIndexed(); // ensure each face has unique vertices

				position = boxGeometry.attributes.position;
				colors = [];

				for ( var i = 0, l = position.count; i < l; i ++ ) {

					color.setHSL( Math.random() * 0.3 + 0.5, 0.75, Math.random() * 0.25 + 0.75 );
					colors.push( color.r, color.g, color.b );

				}

				boxGeometry.addAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );

				for ( var i = 0; i < 10; i ++ ) {

					var boxMaterial = new THREE.MeshPhongMaterial( { specular: 0xffffff, flatShading: true, vertexColors: THREE.VertexColors } );
					boxMaterial.color.setHSL( Math.random() * 0.2 + 0.5, 0.75, Math.random() * 0.25 + 0.75 );

					var box = new THREE.Mesh( boxGeometry, boxMaterial );
					box.position.x = Math.floor( Math.random() * 20 - 10 ) * 20;
					box.position.y = Math.floor( Math.random() * 20 );
					box.position.z = Math.floor( Math.random() * 20 - 10 ) * 50;

					scene.add( box );
					objects.push( box );

				}

				//

				renderer = new THREE.WebGLRenderer( {
					 antialias: true,
					 alpha:true
					 } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				//
				controls = new FirstPersonCameraControl( camera, renderer.domElement );
				controls.enabled = true;			

				window.addEventListener( 'resize', onWindowResize, false );

				for (var m = 0; m < 10; m++) {
					loadObj()
					cnt++
				}
			}

			function loadObj() {
				new RGBELoader()
				.setDataType( THREE.UnsignedByteType )
				.setPath( 'textures/equirectangular/' )
				.load( 'pedestrian_overpass_2k.hdr', function ( texture ) {

					var cubeGenerator = new EquirectangularToCubeGenerator( texture, { resolution: 1024 } );
					cubeGenerator.update( renderer );

					var pmremGenerator = new PMREMGenerator( cubeGenerator.renderTarget.texture );
					pmremGenerator.update( renderer );

					var pmremCubeUVPacker = new PMREMCubeUVPacker( pmremGenerator.cubeLods );
					pmremCubeUVPacker.update( renderer );

					var envMap = pmremCubeUVPacker.CubeUVRenderTarget.texture;

					// model

					var loader = new GLTFLoader().setPath( 'models/gltf/Monster/glTF/' );
					loader.load( 'Monster.gltf', function ( gltf ) {

						gltf.scene.traverse( function ( child ) {

							if ( child.isMesh ) {

								child.material.envMap = envMap;

							}

						} );
						var animations = gltf.animations;

						if ( animations && animations.length ) {

							mixers[mixerCnt] = new THREE.AnimationMixer( gltf.scene );

							for ( var i = 0; i < animations.length; i ++ ) {

								var animation = animations[ i ];

								// There's .3333 seconds junk at the tail of the Monster animation that
								// keeps it from looping cleanly. Clip it at 3 seconds
								// if ( sceneInfo.animationTime ) {

									animation.duration = 3;

								// }

								var action = mixers[mixerCnt].clipAction( animation );
								action.play();

							}

							mixerCnt++
						}

						var change =  1;
						// if (cnt % 2 == 0) {
						// 	change =  -1
						// }
						gltf.scene.position.set(change * Math.floor( Math.random() * 20 - 10 ) * 20,
						change * Math.floor( Math.random() * 40 - 10 ),
						change * Math.floor( Math.random() * 40 - 10 ) * 20)
						scene.add( gltf.scene );
					} );

					pmremGenerator.dispose();
					pmremCubeUVPacker.dispose();

					// scene.background = cubeGenerator.renderTarget;

				} );
			}

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			var dis = 0
			var change = false
			function animate() {
				requestAnimationFrame( animate );

				controls.update();
				// // console.log(clock.getDelta())
				// for (var i = 0; i < 10; i++) {
				// 	if (mixers[i]) {
				// 		mixers[i].update( 0.01 );
				// 	}
				// }
				// // if ( mixer ) mixer.update( 0.01 );
				renderer.render( scene, camera );
			}
		</script>
	</body>
</html>
