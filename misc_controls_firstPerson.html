<!DOCTYPE html>
<html lang="en">
	<head>
		<title>AR DEMO</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
		<style>
			* {
			  margin: 0;
			  padding: 0;
			}
		  </style>
	</head>
	<body>
		
		<video id="video" style="position: absolute; z-index: -1; 
		top: 0;
		left: 0;
		width: 100%;
		height: 100%;
		object-fit: fill;" >
		</video>
		<div>
		  <button id="capture">打开相机</button>
		</div>
		<!-- <canvas id="canvas" width="480" height="320"></canvas> -->
		<script>
		//   //访问用户媒体设备的兼容方法
		//   function getUserMedia(constraints, success, error) {
		// 	if (navigator.mediaDevices.getUserMedia) {
		// 	  //最新的标准API
		// 	  navigator.mediaDevices.getUserMedia(constraints).then(success).catch(error);
		// 	} else if (navigator.webkitGetUserMedia) {
		// 	  //webkit核心浏览器
		// 	  navigator.webkitGetUserMedia(constraints, success, error)
		// 	} else if (navigator.mozGetUserMedia) {
		// 	  //firfox浏览器
		// 	  navigator.mozGetUserMedia(constraints, success, error);
		// 	} else if (navigator.getUserMedia) {
		// 	  //旧版API
		// 	  navigator.getUserMedia(constraints, success, error);
		// 	}
		//   }
	  
		//   let video = document.getElementById('video');
		// //   let canvas = document.getElementById('canvas');
		// //   let context = canvas.getContext('2d');
	  
		//   function success(stream) {
		// 	//兼容webkit核心浏览器
		// 	let CompatibleURL = window.URL || window.webkitURL;
		// 	//将视频流设置为video元素的源
		// 	console.log(stream);
	  
		// 	//video.src = CompatibleURL.createObjectURL(stream);
		// 	video.srcObject = stream;
		// 	video.play();
		//   }
	  
		//   function error(error) {
		// 	console.log(`访问用户媒体设备失败${error.name}, ${error.message}`);
		//   }
	  
		//   if (navigator.mediaDevices.getUserMedia || navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia) {
		// 	//调用用户媒体设备, 访问摄像头
		// 	getUserMedia({
		// 	  video: {
		// 		width: 480,
		// 		height: 320
		// 	  }
		// 	}, success, error);
		//   } else {
		// 	alert('不支持访问用户媒体');
		//   }
	  
		  document.getElementById('capture').addEventListener('click', function () {
			// context.drawImage(video, 0, 0, 480, 320);
			getRealMedia()
		  })

		function getRealMedia() {
        if (!navigator.mediaDevices.getUserMedia) {
          Toast('您的系统暂不支持AR导航');
          return;
        }

        // console.log(window.innerHeight - this.canvas.height)

        navigator.mediaDevices.enumerateDevices()
          .then(devices => {
            var videoDevices = [];
            devices.forEach(function (device) {
              if (device.kind == "videoinput") {
                videoDevices.push(device.deviceId)
              }
            });
            console.log(videoDevices)
            var constraints = {
              width: 375,
              height: 500,
              deviceId: {
                exact: videoDevices[videoDevices.length - 1]
              }
            };
            return navigator.mediaDevices.getUserMedia({
              video: constraints
            });

          })
          .then(stream => {
            let video = document.getElementById('video');
            video.srcObject = stream;
            video.play();
            stopId = stream.getTracks()[stream.getTracks().length - 1];
          })
          .catch(e => console.error(e));
        // setTimeout(() => {
        //   this.getCanvasLine(this.navDetail.cvsDirection)
        // }, 1000);
      }
		
		</script>



		<script type="module">

			import * as THREE from './three.module.js';

			import { FirstPersonControls } from './FirstPersonControls.js';
			import { GLTFLoader } from './GLTFLoader.js';
			import { RGBELoader } from './RGBELoader.js';
			import { EquirectangularToCubeGenerator } from './EquirectangularToCubeGenerator.js';
			import { PMREMGenerator } from './PMREMGenerator.js';
			import { PMREMCubeUVPacker } from './PMREMCubeUVPacker.js';

			var mixerCnt = 0
			var mixer;
			var mixers = []
			var clock = new THREE.Clock();

			var camera, scene, renderer, controls;

			var objects = [];

			var raycaster;

			var moveForward = false;
			var moveBackward = false;
			var moveLeft = false;
			var moveRight = false;
			var canJump = false;

			var prevTime = performance.now();
			var velocity = new THREE.Vector3();
			var direction = new THREE.Vector3();
			var vertex = new THREE.Vector3();
			var color = new THREE.Color();

			var cnt = 0

			var gltfObj;

			init();
			animate();

			function init() {

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 10000 );
				// camera.position.set( 3,1,7 );
				camera.position.y = 200;
				camera.position.z = 1000;

				scene = new THREE.Scene();
				scene.background = null;
				// scene.fog = new THREE.Fog( 0xffffff, 0, 7500 );

				var light = new THREE.DirectionalLight( 0xffffff, 1 );
				light.position.set( 0.5, 1, 0.75 );
				scene.add( light );
				var light2 = new THREE.AmbientLight( 0xffffff);
				light2.position.set( 0.5, 1, 0.75 );
				scene.add( light2 );

				controls = new FirstPersonControls( camera );
				controls.lookSpeed = 0.2; //鼠标移动查看的速度
				controls.movementSpeed = 20; //相机移动速度
				controls.noFly = true;
				controls.constrainVertical = true; //约束垂直
				controls.verticalMin = 1.0;
				controls.verticalMax = 2.0;
				controls.lon = 100; //进入初始视角x轴的角度
				controls.lat = 0; //初始视角进入后y轴的角度				


				raycaster = new THREE.Raycaster( new THREE.Vector3(), new THREE.Vector3( 0, - 1, 0 ), 0, 10 );

				// floor

				var floorGeometry = new THREE.PlaneBufferGeometry( 2000, 2000, 100, 100 );
				floorGeometry.rotateX( - Math.PI / 2 );

				// vertex displacement

				var position = floorGeometry.attributes.position;

				for ( var i = 0, l = position.count; i < l; i ++ ) {

					vertex.fromBufferAttribute( position, i );

					vertex.x += Math.random() * 20 - 10;
					vertex.y += Math.random() * 2;
					vertex.z += Math.random() * 20 - 10;

					position.setXYZ( i, vertex.x, vertex.y, vertex.z );

				}

				floorGeometry = floorGeometry.toNonIndexed(); // ensure each face has unique vertices

				position = floorGeometry.attributes.position;
				var colors = [];

				for ( var i = 0, l = position.count; i < l; i ++ ) {

					color.setHSL( Math.random() * 0.3 + 0.5, 0.75, Math.random() * 0.25 + 0.75 );
					colors.push( color.r, color.g, color.b );

				}

				floorGeometry.addAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );

				var floorMaterial = new THREE.MeshBasicMaterial( { vertexColors: THREE.VertexColors } );

				var floor = new THREE.Mesh( floorGeometry, floorMaterial );
				// scene.add( floor );

				// objects

				var boxGeometry = new THREE.BoxBufferGeometry( 20, 20, 20 );
				boxGeometry = boxGeometry.toNonIndexed(); // ensure each face has unique vertices

				position = boxGeometry.attributes.position;
				colors = [];

				for ( var i = 0, l = position.count; i < l; i ++ ) {

					color.setHSL( Math.random() * 0.3 + 0.5, 0.75, Math.random() * 0.25 + 0.75 );
					colors.push( color.r, color.g, color.b );

				}

				boxGeometry.addAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );

				for ( var i = 0; i < 10; i ++ ) {

					var boxMaterial = new THREE.MeshPhongMaterial( { specular: 0xffffff, flatShading: true, vertexColors: THREE.VertexColors } );
					boxMaterial.color.setHSL( Math.random() * 0.2 + 0.5, 0.75, Math.random() * 0.25 + 0.75 );

					var box = new THREE.Mesh( boxGeometry, boxMaterial );
					box.position.x = Math.floor( Math.random() * 20 - 10 ) * 20;
					box.position.y = Math.floor( Math.random() * 20 );
					box.position.z = Math.floor( Math.random() * 20 - 10 ) * 50;

					scene.add( box );
					objects.push( box );

				}

				//

				renderer = new THREE.WebGLRenderer( {
					 antialias: true,
					 alpha:true
					 } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				//

				window.addEventListener( 'resize', onWindowResize, false );


				for (var m = 0; m < 10; m++) {
					loadObj()
					cnt++
				}
				

			}

			function loadObj() {
				new RGBELoader()
				.setDataType( THREE.UnsignedByteType )
				.setPath( 'textures/equirectangular/' )
				.load( 'pedestrian_overpass_2k.hdr', function ( texture ) {

					var cubeGenerator = new EquirectangularToCubeGenerator( texture, { resolution: 1024 } );
					cubeGenerator.update( renderer );

					var pmremGenerator = new PMREMGenerator( cubeGenerator.renderTarget.texture );
					pmremGenerator.update( renderer );

					var pmremCubeUVPacker = new PMREMCubeUVPacker( pmremGenerator.cubeLods );
					pmremCubeUVPacker.update( renderer );

					var envMap = pmremCubeUVPacker.CubeUVRenderTarget.texture;

					// model

					var loader = new GLTFLoader().setPath( 'models/gltf/Monster/glTF/' );
					loader.load( 'Monster.gltf', function ( gltf ) {

						gltf.scene.traverse( function ( child ) {

							if ( child.isMesh ) {

								child.material.envMap = envMap;

							}

						} );
						var animations = gltf.animations;

						if ( animations && animations.length ) {

							mixers[mixerCnt] = new THREE.AnimationMixer( gltf.scene );

							for ( var i = 0; i < animations.length; i ++ ) {

								var animation = animations[ i ];

								// There's .3333 seconds junk at the tail of the Monster animation that
								// keeps it from looping cleanly. Clip it at 3 seconds
								// if ( sceneInfo.animationTime ) {

									animation.duration = 3;

								// }

								var action = mixers[mixerCnt].clipAction( animation );
								action.play();

							}

							mixerCnt++
						}

						var change =  1;
						// if (cnt % 2 == 0) {
						// 	change =  -1
						// }
						gltf.scene.position.set(change * Math.floor( Math.random() * 20 - 10 ) * 20,
						change * Math.floor( Math.random() * 40 - 10 ),
						change * Math.floor( Math.random() * 40 - 10 ) * 20)
						scene.add( gltf.scene );

						// //
						// var obj1 = gltf.scene.clone()
						// obj1.position.set(Math.floor( Math.random() * 20 - 10 ) * 20,
						// Math.floor( Math.random() * 20 - 10 ) * 20,
						// Math.floor( Math.random() * 20 - 10 ) * 20)
						// scene.add( obj1 );




						gltfObj = gltf.scene.clone()
						// scene.add( gltfObj );



					} );

					pmremGenerator.dispose();
					pmremCubeUVPacker.dispose();

					// scene.background = cubeGenerator.renderTarget;

				} );
			}

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			var dis = 0
			var change = false
			function animate() {
				var r = (Math.random()) / 200
				if (change) {
					r = -1 * r
				}

				dis += r
				if (dis > 2) {
					change = true
				}

				if (dis <0.5) {
					change = false
				}


				// console.log(dis)
				controls.update(r);
				requestAnimationFrame( animate );
				// console.log(clock.getDelta())
				for (var i = 0; i < 10; i++) {
					if (mixers[i]) {
						mixers[i].update( 0.01 );
					}
				}
				// if ( mixer ) mixer.update( 0.01 );
				renderer.render( scene, camera );
			}

		</script>
	</body>
</html>
